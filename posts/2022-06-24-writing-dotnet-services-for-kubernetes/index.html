<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Mike Hadlow C# .NET technical blog."><meta name=author content="Mike Hadlow"><meta property="og:url" content="https://mikehadlow.com/posts/2022-06-24-writing-dotnet-services-for-kubernetes/"><meta property="og:type" content="article"><meta property="og:title" content="Writing .NET Application Services for Kubernetes"><meta property="og:description" content="In a traditional .NET distributed application, application services (not to be confused with the Kubernetes &lsquo;service&rsquo; object) would either be written as IIS hosted web applications or Windows Services. When building .NET (micro)services to be deployed in a Kubernetes cluster pretty much every facet of the service needs to be reconsidered, not only the hosting environment but the way configuration is accessed, how logging and monitoring work, and the options for state management and memory considerations. In this post I&rsquo;ll bring my experience of migrating .NET applications to Kubernetes to enumerate some of the main ways that you&rsquo;ll need to change the way you write them."><meta property="og:image" content="https://mikehadlow.com/img/blog-image.png"><title>Mike Hadlow</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css></head><body><nav class="navbar is-dark" role=navigation aria-label="main navigation"><div class=container><div class=navbar-brand><a href=/ class=navbar-item><strong>Mike Hadlow</strong></a>
<a role=button class=navbar-burger aria-label=menu aria-expanded=false data-target=menu><span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span></a></div><div id=menu class=navbar-menu><div class=navbar-start><a href=https://mikehadlow.com/top/about/ class=navbar-item>About</a>
<a href=https://mikehadlow.com/top/contact/ class=navbar-item>Contact</a>
<a href=https://twitter.com/mikehadlow target=_blank rel="noopener noreferrer" class=navbar-item><svg height="24" viewBox="328 355 335 276" width="24" aria-hidden="true"><path style="fill:#3ba9ee" d="M630 425A195 195 0 01331 6e2a142 142 0 0097-30 70 70 0 01-58-47 70 70 0 0031-2 70 70 0 01-57-66 70 70 0 0028 5 70 70 0 01-18-90 195 195 0 00141 72 67 67 0 01116-62 117 117 0 0043-17 65 65 0 01-31 38 117 117 0 0039-11 65 65 0 01-32 35z"/></svg></a><a href=https://github.com/mikehadlow target=_blank rel="noopener noreferrer" class=navbar-item><svg height="24" viewBox="0 0 16 16" width="24" aria-hidden="true"><path style="fill:#fff" fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a></div></div></div></nav><section class=section><div class=container><div class=columns><div class="column is-two-thirds"><h1 class=title>Writing .NET Application Services for Kubernetes</h1><p class=subtitle>By Mike Hadlow, published Jun 24, 2022</p><div><article id=content class=content><p>In a traditional .NET distributed application, application services (not to be confused with the Kubernetes &lsquo;service&rsquo; object) would either be written as IIS hosted web applications or Windows Services. When building .NET (micro)services to be deployed in a <a href=https://kubernetes.io/>Kubernetes</a> cluster pretty much every facet of the service needs to be reconsidered, not only the hosting environment but the way configuration is accessed, how logging and monitoring work, and the options for state management and memory considerations. In this post I&rsquo;ll bring my experience of migrating .NET applications to Kubernetes to enumerate some of the main ways that you&rsquo;ll need to change the way you write them.</p><p>First some caveats. I don&rsquo;t intend this post to be an introduction to Kubernetes, or a justification of why you should use Kubernetes. Nor is it a tutorial on how to write distributed applications or .NET application services. It&rsquo;s intended audience is my past self about a year and a half ago. I would have very much appreciated a short guide on the changes I would have to make to redesign my .NET application services to take full advantage of Kubernetes.</p><p>I&rsquo;ve created a minimal example service <a href=https://github.com/mikehadlow/NetOnKubernetes>NetOnKubernetes</a> that I&rsquo;ve shared on GitHub that implements the recommendations below. Please feel free to use it as a starting point for your own application services.</p><h3 id=application-service-design>Application Service Design</h3><p>Some general application design guidelines:</p><ul><li>Build stateless horizontally scalable services. See the <a href=https://12factor.net/>12 factor apps</a> guidelines.</li><li>Use Linux containers. .NET is now cross platform and runs well on Linux. Avoid the bloat and inevitable friction of Windows Containers.</li><li>Consider the container immutable. Do not change the local file system. If you need a file system, use a volume mount.</li><li>One container per pod. Although the <a href=https://learnk8s.io/sidecar-containers-patterns>sidecar pattern</a> is a popular one, it&rsquo;s perfectly reasonable to have a complete distributed application without a single sidecar in sight. Like all popular patterns, only use it if you have a real need.</li><li>Every application is a console application. Processes are managed by Kubernetes. HTTP services should be standalone console based web apps using the Kestrel webserver.</li></ul><p>One of the main advantages you&rsquo;ll find writing application services for Kubernetes is that the platform now provides many things that you would previously have had to include in your application. As I&rsquo;ll describe below things such as configuration, logging, metrics, and security all become simpler to implement.</p><h3 id=building-your-container-images>Building your container images</h3><p>Kubernetes is primarily a container orchestration framework. Your applications/services need to be built and deployed as (usually Docker) containers. Microsoft have published a very good guide to building and running containerized .NET applications, <a href=https://dotnet.microsoft.com/en-us/download/e-book/microservices-architecture/pdf>NET Microservices Architecture for Containerized .NET Applications</a> that I&rsquo;d recommend reading, although it doesn&rsquo;t cover Kubernetes the advice on creating container images and microservice architecture is very good.</p><p>Although it&rsquo;s possible to compile your application in a traditional build server and then create the runtime container image from the compiled binaries, it&rsquo;s easier to combine the build and runtime in a single multi-stage docker file, that way you control the environment for both build and deployment. Here is a very simple example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/aspnet:6.0-bullseye-slim AS runtime</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 80</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/sdk:6.0-bullseye-slim AS sdk</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> build_number<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>.0.0<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> src/ .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># restore nuget packages</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet restore<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># build</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet build --no-restore <span style=color:#e6db74>&#34;-p:Version=</span><span style=color:#e6db74>${</span>build_number<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># test</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet test --no-build GreetingService.Tests/GreetingService.Tests.csproj<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># publish</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet publish --no-build -o output<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># create runtime image</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> runtime AS final</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>sdk /app/output/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;./GreetingsService&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>As you can see there are multiple <code>FROM</code> clauses. Each one discards the previous image so the final <code>final</code> image is small.</p><p>Note, it&rsquo;s quite common to see just the .csproj file copied first for the restore phase, then the rest of the <code>src</code> contents copied for the build. This will give you smaller, more efficient, layer cacheing. Although if you are using an ephemeral build server such as GitHub Actions, there&rsquo;s probably little to be gained. Personally I like to keep things simple.</p><p>Build the image with docker build:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>&gt; docker build -t greetings-service:0.0.1 --build-args build_number=1.0.0 .
</span></span></code></pre></div><p>Once your container images are built, you should publish them to your internal image repository. GitHub provides a container registry as does Azure and all other cloud providers.</p><h3 id=deploying-to-kubernetes>Deploying to Kubernetes</h3><p>In the simplest case for an aspnet service you can deploy your application/service to Kubernetes by simply running a deployment specifying your image and the number of replicas you want:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service-deployment</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>greetings-service:0.0.1</span>
</span></span></code></pre></div><p>You will also need a Kubernetes &ldquo;service&rdquo; to direct traffic to your pods, something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service-service-port</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>3456</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>targetPort</span>: <span style=color:#ae81ff>5432</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>nodePort</span>: <span style=color:#ae81ff>30001</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>LoadBalancer</span>
</span></span></code></pre></div><p>Use <code>kubectl apply</code> to run the deployment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>&gt; kubectl apply -f greetings-service-deployment.yaml
</span></span></code></pre></div><p>Consider using <a href=https://helm.sh/>Helm</a> to template your deployments for any but the very simplest cases. I&rsquo;ve also had <a href=https://kustomize.io/>Kustomize</a> recommended to me, which looks a little simpler than Helm, but I&rsquo;ve not used it myself.</p><h3 id=build-and-deployment>Build and Deployment</h3><p>Your build and deploy pipeline will look something like this:</p><ol><li><code>docker build .</code> Build your service container image.</li><li><code>docker push ...</code> Push your image to your image repository.</li><li><code>kubectl apply ...</code> Execute the YAML file defining your deployment against your Kubernetes cluster.</li></ol><p>If you are using <a href=https://github.com/>GitHub</a> for source control <a href=https://github.com/features/actions>GitHub actions</a> are a good choice for running these steps on a successful commit or pull request merge.</p><h3 id=source-control>Source Control</h3><p>One of the great advantages of Kubernetes is that it enables source controlled immutable infrastructure. Your application is no longer deployed with a build pipeline and environment subject to arbitrary imperative commands or GUI clicks by a sysadmin. Instead we should treat the Dockerfile, Kubernetes object YAML files, and build pipeline scripts as the source of truth (&ldquo;Filesystems as the Source of Truth&rdquo;). Any changes to the infrastructure should only be enacted by modifying and committing these files. This enables a fully visible and audited history of infrastructure changes.</p><p>My personal preference is to store the Dockerfile, Kubernetes object YAML files, and build pipeline script in the same repo as the service/application source code.</p><h3 id=application-lifecycle>Application Lifecycle</h3><p>It&rsquo;s general good advice to make your application easily disposable, with fast startup and graceful shutdown. If your application does this and fails fast when it encounters a problem, then you&rsquo;re good to go. Only use the various hooks Kubernetes provides that I describe below if you can&rsquo;t meet these conditions.</p><p>It can also be worth adding liveness and/or readiness probes to your application. These are HTTP endpoints that Kubernetes can query to ascertain the state of your application. If your application needs to restart, it&rsquo;s best to simply fail fast and let Kubernetes restart the container, but if that is impractical for some reason you can return an HTTP failure code (500) from your liveness endpoint and Kubernetes will restart the container for you. Readiness probes are probably the most useful. They signal to Kubernetes that your application is ready to receive requests. This means that traffic will not be routed to the container until Kubernetes sees a 200 response. Very useful if your application has a long startup time.</p><p>Here is an example of liveness and readiness endpoints:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// liveness probe, return HTTP status code 500 if you want the container to be restarted</span>
</span></span><span style=display:flex><span>app.MapGet(<span style=color:#e6db74>&#34;/live&#34;</span>, () =&gt; Results.Ok());
</span></span><span style=display:flex><span><span style=color:#75715e>// rediness probe, return 200 OK when the application is ready to respond to requests.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// this can turn on and off if necessary, for example if a backend service is not available.</span>
</span></span><span style=display:flex><span>app.MapGet(<span style=color:#e6db74>&#34;/ready&#34;</span>, () =&gt; hasStarted ? Results.Ok() : Results.StatusCode(<span style=color:#ae81ff>500</span>));
</span></span></code></pre></div><p>Configure them in your deployment YAML like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>greetings-service:0.0.3</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>livenessProbe</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/live</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>port</span>: <span style=color:#ae81ff>5432</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>readinessProbe</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/ready</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>port</span>: <span style=color:#ae81ff>5432</span>
</span></span></code></pre></div><p>Kubernetes can also notify your container of startup and (more usefully) shutdown with the use use of <a href=https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/>Container Lifecycle Hooks</a>. You provide HTTP endpoints for the Kubernetes <code>PostStart</code> and <code>PreStop</code> events. Kubernetes won&rsquo;t kill the container until the <code>PreStop</code> event completes, so it&rsquo;s a good opportunity to gracefully shutdown:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// PostStart and PreStop event hooks.</span>
</span></span><span style=display:flex><span>app.MapGet(<span style=color:#e6db74>&#34;/postStart&#34;</span>, (ILogger&lt;GreetingApp&gt; logger) 
</span></span><span style=display:flex><span>    =&gt; logger.LogInformation(<span style=color:#e6db74>&#34;PostStart event&#34;</span>));
</span></span><span style=display:flex><span>app.MapGet(<span style=color:#e6db74>&#34;/preStop&#34;</span>, (ILogger&lt;GreetingApp&gt; logger) 
</span></span><span style=display:flex><span>    =&gt; logger.LogInformation(<span style=color:#e6db74>&#34;PreStop event&#34;</span>));
</span></span></code></pre></div><p>Configure them in the deployment YAML file like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>greetings-service:0.0.3</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>lifecycle</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>postStart</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/postStart</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>port</span>: <span style=color:#ae81ff>5432</span>          
</span></span><span style=display:flex><span>          <span style=color:#f92672>preStop</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/preStop</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>port</span>: <span style=color:#ae81ff>5432</span>          
</span></span></code></pre></div><h3 id=memory-and-cpu-limits>Memory and CPU Limits</h3><p>It&rsquo;s important to set resource quotas for your container so that Kubernetes can correctly schedule your pod to a node. This means configuring resource limits and requests in your deployment YAML. Unless you&rsquo;ve got a particular problem you want to solve, it&rsquo;s easiest and simplest just to set the limits and requests to the same values. If you don&rsquo;t set limits and requests, Kubernetes will gives your pod a <em>best effort</em> quality of service which give no guarantee that it wont be evicted when node resources are short. Setting limits and requests gives you <em>guaranteed</em> QoS. Be conservative with the values you choose. Your pod will be throttled if it exceeds its CPU limits, and restarted if it exceeds its memory limits.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>greetings-service:0.0.3</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>200Mi</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>100m</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>200Mi</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>100m</span>
</span></span></code></pre></div><h3 id=configuration>Configuration</h3><p>Configuration here means everything that is different for deploying in different environments (e.g. development, QA, staging, production). A single container image should be deployable to any environment without modification. The easiest way to manage configuration in a Kubernetes deployed app is via environment variables. These also have the advantage of being language and OS-agnostic.</p><p>Environment variables can be configured using a Kubernetes <a href=https://kubernetes.io/docs/concepts/configuration/configmap/>ConfigMap</a>. Here is a simple example which defines two values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ConfigMap</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>GREETINGS_MESSAGE</span>: <span style=color:#e6db74>&#34;Hello World From Config Map!&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>GREETINGs_NUMBER</span>: <span style=color:#e6db74>&#34;1234&#34;</span>
</span></span></code></pre></div><p>Apply the ConfigMap&rsquo;s values to a pod in the deployment YAML using <code>envFrom</code> in the pod spec. This will apply all the <code>data</code> values from the ConfigMap as environment variables to the pod.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service-deployment</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>greetings-service:0.0.3</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>envFrom</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>configMapRef</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span></code></pre></div><p>ASPNET has very convenient build-in support to access environment variables. The default builder includes an environment variable configuration provider, so accessing an environment variable is simply a case of using a string indexer on <code>IConfiguration</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>app.MapGet(<span style=color:#e6db74>&#34;/&#34;</span>, (IConfiguration configuration) =&gt; 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> message = configuration[<span style=color:#e6db74>&#34;GREETINGS_MESSAGE&#34;</span>] 
</span></span><span style=display:flex><span>        ?? <span style=color:#e6db74>&#34;Hello World! env var not found.&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Greeting(message);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>For sensitive values, consider using a Kubernetes <a href=https://kubernetes.io/docs/concepts/configuration/secret/>Secret</a>. These are configured differently in Kubernetes, but as with a ConfigMap they are applied to the pod environment and accessed as environment variables by the application. Note that the default Kubernetes configuration is not very secure and you should configure encryption at rest in etcd and enable TLS/SSL between etcd and your pods. Also beware of who has access to etcd. It&rsquo;s also recommended to take advantage of your cloud providers&rsquo; secrets provider if it has one.</p><h3 id=logging>Logging</h3><p>The Kubernetes way is have your application/service log to stdout and have a log collector/processor on each node (deployed as a <a href=https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/>daemonset</a>) collect and forward the logs to an aggregator. A popular combination is <a href=https://github.com/fluent/fluent-bit>Fluent Bit</a> and <a href=https://github.com/fluent/fluentd>Fluentd</a> nicely described in this blog post, <a href=https://logz.io/blog/fluentd-vs-fluent-bit/>Fluentd vs. Fluent Bit: Side by Side Comparison</a></p><p>It&rsquo;s best practice to log event-per-output-line in a structured format such as JSON that the log collector can understand and parse. Configure your service to log event-per-line JSON like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder();
</span></span><span style=display:flex><span>builder.Logging.ClearProviders();
</span></span><span style=display:flex><span>builder.Logging.AddJsonConsole(options =&gt; 
</span></span><span style=display:flex><span>{ 
</span></span><span style=display:flex><span>    options.IncludeScopes = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    options.TimestampFormat = <span style=color:#e6db74>&#34;yyyy:MM:dd hh:mm:ss &#34;</span>;
</span></span><span style=display:flex><span>    options.JsonWriterOptions = <span style=color:#66d9ef>new</span> JsonWriterOptions
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// sometimes useful to change this to true when testing locally.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// but it needs to be false for Fluent Bit to </span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// process log lines correctly</span>
</span></span><span style=display:flex><span>        Indented = <span style=color:#66d9ef>false</span> 
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>See <a href=https://docs.microsoft.com/en-gb/dotnet/core/extensions/console-log-formatter>Console Log Formatting</a> and the <a href=https://github.com/dotnet/runtime/issues/34742>discussion around adding formatted JSON logs in .NET 5.0</a></p><p>Having said all this, it&rsquo;s worth pointing out that a new, cross vendor, emerging standard for all your tracing, metrics, and logging needs is <a href=https://opentelemetry.io/>OpenTelemetry</a>. Microsoft are <a href=https://devblogs.microsoft.com/dotnet/opentelemetry-net-reaches-v1-0/>committed to supporting it</a> which means that the good news is changing your service to export OTel logs should be just a question adding a new logging provider. You can check the current status of OTel on their <a href=https://opentelemetry.io/status/>status page</a>. When OTel is ready for production it&rsquo;ll be a case of installing the OTel collector on your Kubernetes cluster and configuring it to communicate with your logging and monitoring tools. See the OTel documentation for more information on this.</p><h3 id=metrics>Metrics</h3><p>The <a href=https://www.cncf.io/>CNCF</a> supported standard for metrics collection is <a href=https://prometheus.io/>Prometheus</a>, usually coupled with <a href=https://grafana.com/oss/grafana/>Grafana</a> to provide dashboards and visualizations. Prometheus is a &ldquo;pull based&rdquo; metric collector, which means that your application provides an HTTP endpoint for Prometheus to query. Service discovery is provided by Kubernetes, so it&rsquo;s simply a question of adding some annotations to the application&rsquo;s deployment YAML:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>greetings-service-deployment</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>greetings-service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>prometheus.io/port</span>: <span style=color:#e6db74>&#39;5432&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>prometheus.io/scrape</span>: <span style=color:#e6db74>&#39;true&#39;</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>A Prometheus client library is available for .NET, <a href=https://github.com/prometheus-net/prometheus-net>prometheus-net</a>. Simply add the NuGet package to your application and add the metrics endpoint:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>app.UseRouting();
</span></span><span style=display:flex><span>app.UseEndpoints(endpoints =&gt; 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    endpoints.MapMetrics();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Now when you navigate to <code>/metrics</code> you will see a range of out-of-the-box metrics that the library provides:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># HELP dotnet_total_memory_bytes Total known allocated memory</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE dotnet_total_memory_bytes gauge</span>
</span></span><span style=display:flex><span>dotnet_total_memory_bytes <span style=color:#ae81ff>3979792</span>
</span></span><span style=display:flex><span><span style=color:#75715e># HELP process_working_set_bytes Process working set</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE process_working_set_bytes gauge</span>
</span></span><span style=display:flex><span>process_working_set_bytes <span style=color:#ae81ff>57937920</span>
</span></span><span style=display:flex><span><span style=color:#75715e># HELP process_private_memory_bytes Process private memory size</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE process_private_memory_bytes gauge</span>
</span></span><span style=display:flex><span>process_private_memory_bytes <span style=color:#ae81ff>45125632</span>
</span></span><span style=display:flex><span><span style=color:#75715e># HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE process_cpu_seconds_total counter</span>
</span></span><span style=display:flex><span>process_cpu_seconds_total 1.421875
</span></span><span style=display:flex><span><span style=color:#75715e># HELP process_start_time_seconds Start time of the process since unix epoch in seconds.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE process_start_time_seconds gauge</span>
</span></span><span style=display:flex><span>process_start_time_seconds 1655909436.368272
</span></span><span style=display:flex><span><span style=color:#75715e># HELP process_open_handles Number of open handles</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE process_open_handles gauge</span>
</span></span><span style=display:flex><span>process_open_handles <span style=color:#ae81ff>662</span>
</span></span><span style=display:flex><span><span style=color:#75715e># HELP process_num_threads Total number of threads</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE process_num_threads gauge</span>
</span></span><span style=display:flex><span>process_num_threads <span style=color:#ae81ff>23</span>
</span></span><span style=display:flex><span><span style=color:#75715e># HELP process_virtual_memory_bytes Virtual memory size in bytes.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE process_virtual_memory_bytes gauge</span>
</span></span><span style=display:flex><span>process_virtual_memory_bytes <span style=color:#ae81ff>2208994299904</span>
</span></span><span style=display:flex><span><span style=color:#75715e># HELP dotnet_collection_count_total GC collection count</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE dotnet_collection_count_total counter</span>
</span></span><span style=display:flex><span>dotnet_collection_count_total<span style=color:#f92672>{</span>generation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>dotnet_collection_count_total<span style=color:#f92672>{</span>generation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>dotnet_collection_count_total<span style=color:#f92672>{</span>generation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>You can add your own counters and meters using the library. See the documentation for more details.</p><p>Note that metrics will also be provided by OpenTelemetry (see logging above), so by the time you read this OpenTelemetry might well be the best option for metrics as well.</p><h3 id=security>Security</h3><p>The debate on Security in Kubernetes is often confused between securing the Kubernetes cluster itself - authenticating and authorising access to the Kubernetes API for developers and administrators working on the cluster, and &ldquo;userland&rdquo; security for the application hosted on the cluster - authenticating and authorising users of the application, such a customer wanting to buy something on your eCommerce site. Because of this confusion it&rsquo;s quite frustrating trying to Google for solutions and approaches to application security. Having said all that, here are my thoughts on <em>application security</em>.</p><p>If you are building any modern HTTP serving application a prerequisite is that you only serve HTTPS over the internet. It&rsquo;s also true that the vast majority of business applications also require some kind of authentication and authorisation. Regardless of whether you are using Kubernetes or not, any distributed application should use Single Sign On (SSO) with a separate Identity Provider (IdP). The prevalent protocol for this is OAuth. For Role Based Access Control (RBAC) individual services need to be able to see claims (user roles and other attributes) passed by the OAuth token, but they don&rsquo;t necessarily need to do the actual token decryption.</p><p>There seem to be two schools of thought on application security in Kubernetes. On one hand are those who suggest that everything in your Kubernetes cluster should be considered trusted and to do things like HTTPS termination and token decryption on ingress. This allows your application services to be simple HTTP servers that don&rsquo;t need to include components for these tasks. One of the main benefits of an application platform is the ability to offload various infrastructure concerns to the platform.</p><p>On the other hand, many people suggest adopting a zero trust approach within the Kubernetes cluster. There are obviously security verses complexity trade-offs on both sides of this debate. Which side you fall on will depend very much on the nature of your application and business.</p><p>With the former approach, you build your services to serve plain unencrypted HTTP, do HTTPS termination and authentication on your ingress reverse proxy. For authentication use an authentication reverse proxy on ingress that can be shared by all your services. This post is very good on authentication proxies. It doesn&rsquo;t mention Kubernetes, but the principle is the same. <a href=http://morganridel.fr/authentication-for-multiple-apps-behind-a-reverse-proxy>Authentication for multiple apps behind a reverse proxy</a> Another good read is <a href=https://www.nginx.com/blog/authenticating-api-clients-jwt-nginx-plus/>Authenticating API Clients with JWT and NGINX Plus</a>, which covers how to do this in detail with the commercial edition of Nginx. If your internal services need to know about internal services or roles etc, the proxy can translate JWT claims into HTTP headers.</p><p>A third, middle way, might be to create a sidecar that can do HTTPS termination and token decryption. Your application can then still be built simply as a pure HTTP service, but external the pod everything is TLS encrypted. Of course it means that you would have to deploy the sidecar alongside every service with the attendant cost and complexity.</p><hr><p>Comment on this post on <a href=https://www.reddit.com/r/programming/comments/vp48u9/writing_net_application_services_for_kubernetes/>Reddit</a></p></article></div></div><div class="column is-one-third box"><div class=content><p><strong>Hi, I&rsquo;m Mike Hadlow. Software developer, architect, blogger and open source developer.</strong></p><p>Find my old blog at <a href=http://mikehadlow.blogspot.com/>Code Rant</a>. This ran from 2005 to 2020 and has hundreds of posts.</p><p><em>All code on this blog is published under an <a href=https://opensource.org/licenses/MIT>MIT licence</a>. You are free to copy it and use it for any purpose without attribution. There is no warranty whatsoever. All non-code text is copyright Mike Hadlow and cannot be reused without permission.</em></p><p><strong>There are no cookies on this site</strong></p><p>The GitHub repository for this site is <a href=https://github.com/mikehadlow/mikehadlow.github.io>here</a>.</p></div></div></div></div></section></body><script>document.addEventListener("DOMContentLoaded",()=>{const e=Array.prototype.slice.call(document.querySelectorAll(".navbar-burger"),0);e.length>0&&e.forEach(e=>{e.addEventListener("click",()=>{const t=e.dataset.target,n=document.getElementById(t);e.classList.toggle("is-active"),n.classList.toggle("is-active")})})})</script></html>